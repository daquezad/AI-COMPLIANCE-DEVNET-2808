"""
Remediation Execution Tools for NSO compliance remediation.
These tools execute remediation actions: sync-to, re-deploy, apply-template.
"""
import json
import logging
from typing import Dict, Any, List
from langchain_core.tools import tool

logger = logging.getLogger("devnet.compliance.tools.remediation")


# =============================================================================
# REMEDIATION ACTION HANDLERS (Abstract - ready for API implementation)
# =============================================================================

def _execute_sync_to(target: Dict[str, Any]) -> Dict[str, Any]:
    """
    Execute a sync-to action on NSO devices.
    
    Args:
        target: Dictionary containing one of:
            - device_names: List of device names to sync
            - device_group: Name of a device group to sync
            - device_name: Single device name to sync
    
    Returns:
        Dictionary with execution result
    """
    device_names = target.get("device_names", [])
    device_group = target.get("device_group")
    device_name = target.get("device_name")
    
    # Normalize to list of devices
    devices = []
    if device_names:
        devices = device_names if isinstance(device_names, list) else [device_names]
    elif device_group:
        # TODO: Resolve device group to list of devices via NSO API
        devices = [f"<devices-from-group:{device_group}>"]
    elif device_name:
        devices = [device_name]
    
    logger.info(f"Executing sync-to on devices: {devices}")
    
    # TODO: Replace with actual NSO API call
    # Example: nso_sync_to(devices)
    return {
        "action": "sync-to",
        "status": "pending_implementation",
        "devices": devices,
        "message": f"sync-to action for {len(devices)} device(s) - API call not yet implemented"
    }


def _execute_redeploy(service_type: str, service_instance: str) -> Dict[str, Any]:
    """
    Execute a re-deploy action on an NSO service.
    
    Args:
        service_type: The type/path of the service (e.g., 'ntp', 'dns', 'l3vpn')
        service_instance: The service instance name to redeploy
    
    Returns:
        Dictionary with execution result
    """
    logger.info(f"Executing re-deploy on service: {service_type}/{service_instance}")
    
    # TODO: Replace with actual NSO API call
    # Example: nso_redeploy_service(service_type, service_instance)
    return {
        "action": "re-deploy",
        "status": "pending_implementation",
        "service_type": service_type,
        "service_instance": service_instance,
        "message": f"re-deploy action for {service_type}/{service_instance} - API call not yet implemented"
    }


def _execute_apply_template(template_name: str, target: Dict[str, Any]) -> Dict[str, Any]:
    """
    Execute an apply-template action on NSO devices.
    
    Args:
        template_name: Name of the NSO template to apply
        target: Dictionary containing one of:
            - device_names: List of device names to apply template to
            - device_group: Name of a device group
            - device_name: Single device name
    
    Returns:
        Dictionary with execution result
    """
    device_names = target.get("device_names", [])
    device_group = target.get("device_group")
    device_name = target.get("device_name")
    
    # Normalize to list of devices
    devices = []
    if device_names:
        devices = device_names if isinstance(device_names, list) else [device_names]
    elif device_group:
        # TODO: Resolve device group to list of devices via NSO API
        devices = [f"<devices-from-group:{device_group}>"]
    elif device_name:
        devices = [device_name]
    
    logger.info(f"Executing apply-template '{template_name}' on devices: {devices}")
    
    # TODO: Replace with actual NSO API call
    # Example: nso_apply_template(template_name, devices)
    return {
        "action": "apply-template",
        "status": "pending_implementation",
        "template_name": template_name,
        "devices": devices,
        "message": f"apply-template '{template_name}' for {len(devices)} device(s) - API call not yet implemented"
    }


# =============================================================================
# LANGCHAIN TOOLS
# =============================================================================

@tool
def execute_remediation_plan(remediation_plan_json: str) -> Dict[str, Any]:
    """
    Execute a remediation plan containing multiple remediation actions.
    
    This tool processes a JSON array of remediation actions generated by the planner.
    Each action specifies what type of remediation to perform (sync-to, re-deploy, 
    or apply-template) and the corresponding targets/parameters.
    
    Args:
        remediation_plan_json: JSON string containing an array of remediation actions.
            Each action must have:
            - id: Unique identifier for the action
            - action: One of "sync-to", "re-deploy", or "apply-template"
            
            For "sync-to" actions:
            - target: Object with one of: device_names (list), device_group (str), or device_name (str)
            
            For "re-deploy" actions:
            - service_type: The service type/path (e.g., "/ncs:services/loopback-demo:loopback-demo
")
            - service_instance: The service instance name
            
            For "apply-template" actions:
            - template_name: Name of the template to apply
            - target: Object with one of: device_names (list), device_group (str), or device_name (str)
    
    Returns:
        Dictionary containing:
        - success: True if all actions were processed
        - total_actions: Number of actions in the plan
        - results: List of results for each action
        - errors: List of any errors encountered
    
    Example Input:
        [
            {
                "id": 1,
                "action": "sync-to",
                "target": {"device_names": ["router1", "router2"]}
            },
            {
                "id": 2,
                "action": "re-deploy",
                "service_type": "ntp",
                "service_instance": "ntp-config-001"
            },
            {
                "id": 3,
                "action": "apply-template",
                "template_name": "baseline-security",
                "target": {"device_group": "core-routers"}
            }
        ]
    
    Example Usage:
        - "Execute the remediation plan"
        - "Run all approved remediation actions"
        - "Apply the fixes from the compliance report"
    """
    logger.info("LLM Tool Call: execute_remediation_plan")
    
    # Parse JSON input
    try:
        actions = json.loads(remediation_plan_json)
        if not isinstance(actions, list):
            actions = [actions]  # Wrap single action in list
    except json.JSONDecodeError as e:
        return {
            "success": False,
            "error": f"Invalid JSON format: {str(e)}",
            "total_actions": 0,
            "results": [],
            "errors": [f"JSON parse error: {str(e)}"]
        }
    
    results = []
    errors = []
    
    for action_item in actions:
        action_id = action_item.get("id", "unknown")
        action_type = action_item.get("action", "").lower()
        
        logger.info(f"Processing action {action_id}: {action_type}")
        
        try:
            if action_type == "sync-to":
                target = action_item.get("target", {})
                if not target:
                    raise ValueError("sync-to action requires 'target' with device_names, device_group, or device_name")
                result = _execute_sync_to(target)
                
            elif action_type == "re-deploy":
                service_type = action_item.get("service_type")
                service_instance = action_item.get("service_instance")
                if not service_type or not service_instance:
                    raise ValueError("re-deploy action requires 'service_type' and 'service_instance'")
                result = _execute_redeploy(service_type, service_instance)
                
            elif action_type == "apply-template":
                template_name = action_item.get("template_name")
                target = action_item.get("target", {})
                if not template_name:
                    raise ValueError("apply-template action requires 'template_name'")
                if not target:
                    raise ValueError("apply-template action requires 'target' with device_names, device_group, or device_name")
                result = _execute_apply_template(template_name, target)
                
            else:
                raise ValueError(f"Unknown action type: '{action_type}'. Must be one of: sync-to, re-deploy, apply-template")
            
            result["id"] = action_id
            results.append(result)
            logger.info(f"Action {action_id} completed: {result.get('status')}")
            
        except Exception as e:
            error_msg = f"Action {action_id} failed: {str(e)}"
            logger.error(error_msg)
            errors.append(error_msg)
            results.append({
                "id": action_id,
                "action": action_type,
                "status": "failed",
                "error": str(e)
            })
    
    success = len(errors) == 0
    return {
        "success": success,
        "total_actions": len(actions),
        "successful_actions": len([r for r in results if r.get("status") != "failed"]),
        "failed_actions": len(errors),
        "results": results,
        "errors": errors if errors else None,
        "message": f"Processed {len(actions)} action(s): {len(actions) - len(errors)} succeeded, {len(errors)} failed"
    }


# Export tools list
remediation_tools = [
    execute_remediation_plan,
]
